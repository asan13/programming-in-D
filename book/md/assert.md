# assert и enforce

В предыдущих двух главах мы увидели, как использовать исключения и инструкции
**scope** для обеспечения корректости программы. **assert** - ещё один мощный
инструмент для достижения той же цели, гарантирующий, что определенные
предположения, на которых основана программа, являются верными.

Иногда бывыает трудно решить, следует ли бросить исключение или вызвать
**assert**. Я использую **assert** во всех приведенных ниже примерах без 
всякого рода обоснований. Различие я объясню позже в этой главе.

Хотя следующее не всегда очевидно, программа полна предположений. Например,
следующая функция написана в предположении, что оба её параметра больше или
равны нулю:

```D
double averageAge(double first, double second) {
    return (first + second) / 2;
}
```

Хотя отрицательное значение вызраста может быть недействительно в программе,
функция все равно производит среднее, невалидный результат может остаться 
незамеченным, и программа продолжит выполнение с некорректными данными.

В другом примере функция предполагает, что она всегда вызывается с двумя
коммандами: "sign" или "dance":

```D
void applyCommand(string command) {
    if (command == "sing") {
        robotSing();

    } else {
        robotDance();
    }
}
```

Из-за этого предположения функция **robotDance()** будет вызываться для любой
команды, отличной от "sign", правильной или нет.

Когда такие предположения хранятся только лишь в мозгу программиста, программа
может работать некорректно. Инструкция **assert** проверяет предположение и,
если оно не верно, немедленно завершает программу.

## Синтаксис

**assert** может использоваться двумя способами:

```D
    assert(logical_expression);
    assert(logical_expression, message);
```

Логическое выражение представляет предположение о программе. **assert**
вычисляет это выражение для проверки предположения. Если значение логического
выражения **истинно**, то предположение считается действительным. Иначе
предположение недействительно и выбрасывается **AssertError**.

Как следует из названия, это исключение наследуется от **Error** и, как вы
помните из главы [Исключения](exceptions.html), такие исключения никогда не 
должны перехватываться. Важно, что бы программа была немедленно завершена, а
не продолжалась с недопустимыми предположениями.

Два неявных предположения функции **averageAge** выше могут быть записаны
двумя вызовами **assert**, как в следующей функции:

```D
double averageAge(double first, double second) {
    assert(first >= 0);
    assert(second >= 0);

    return (first + second) / 2;
}

void main() {
    auto result = averageAge(-1, 10);
}
```

Эти утвердительные проверки имеют значение "предположим, что оба значения
возраста больше или равны нулю". Также их можно рассматривать  в значении "эта
функция может работать правильно, только если оба возраста больше или равны
нулю".

Каждый **assert** проверяет предположение и завершает программу, выкидывая 
ислючение **AssertError**, если предположение не верно:

    **core.exception.AssertError@deneme(2): Assertion failure**

Часть сообщения после символа @ указывает на исходный файл и номер строки
неудавшенйся проверки **assert**. В соответствии с вышеуказанным, **assert**
ошибся на строке 2 файла **deneme.d**.

Другой синтаксис позволяет напечатать пользовательское сообщение, когда
проверка не удалась:

```D
        assert(first >= 0, "Age cannot be negative.");
```

Вывод:

    **core.exception.AssertError@deneme.d(2): Age cannot be negative.**

Иногда для программы считается невозможным даже пойти по определенному пути 
выполнения кода. В таких случаях принято использовать литерал **false** в
качестве логического выражения, что бы вызвать сбой **assert**.  Например,
что бы показать, что функция **applyCommand()** не может вызываться с
командами, отличными от "sign" и "dance", и для защиты от таких вызовов,
в ветку, в которую _невозможно_ попасть, вставляется **assert(false)**:

```D
void applyCommand(string command) {
    if (command == "sing") {
        robotSing();

    } else if (command == "dance") {
        robotDance();

    } else {
        assert(false);
    }
}
```

Функция гарантирует работу только с двумя коммандами, о которых она знает.
(**Примечание:** В качестве альтернативного варианта здесь можно использовать
инструкцию [final switch](switch_case.html).)


## static assert 

Поскольку **assert** выполняет проверки на корректность выполняемых программ,
эти проверки применяются, когда программа действительно работает. Существуют
другие проверки, относящиеся к структуре программы, которые могут выполнятся
даже во время компиляции.

**static assert** является двойником **assert**, применяемым во время
компиляции.  Его преимущество в том, что он не позволяет даже скомпилировать
программу, которая в ином случае выполнялась бы неправильно. При этом 
естественным требованием является возможность оценить логическое выражение во
время компиляции. 

Например, если предположить, что заголовок меню будет напечатон на устройстве
вывода с ограниченной шириной, следующий **static assert** гарантирует, что он
никогда не будет шире этого предела:

```D
    enum dstring menuTitle = "Command Menu";
    static assert(menuTitle.length <= 16);
```

Обратите внимание на то, что строка определяется, как **enum**, так что ее
длина вычисляется во время компиляции.

Предположим, программист изменил этот заголовок, что бы сделать его более
описательным:

```D
    enum dstring menuTitle = "Directional Commands Menu";
    static assert(menuTitle.length <= 16);
```

**static assert** не дает скомпилировать программу:

    **Error: static assert  (25u <= 16u) is false**

Это напомнит программисту об ограничении устройства вывода.

**static assert** еще более полезен при использовании в шаблонах. Мы
познакомимся с шаблонами в следующих главах.


## assert **даже если абсолютная истина**

Я подчеркиваю выражение "абсолютная истина", поскольку никогда не ожидается,
что предположения о программе ложны. Большое число ошибок в программе
вызвано предположениями, считающимися абсолютно истинными.

Поэтому пользуйтесь проверками **assert**, даже если они кажутся ненужными.
Давайте взглянём на следующую функцию, возвращающую число дней в месяцах в
заданном году:

```D
int[] monthDays(in int year) {
    int[] days = [
        31, februaryDays(year),
        31, 30, 31, 30, 31, 31, 30, 31, 30, 31
    ];

    assert((sum(days) == 365) ||
           (sum(days) == 366));

    return days;
}
```

**assert** может показаться ненужным, потому что функция, естественно,
вернет либо 365, либо 366 дней.  Однако, эта проверка защищает от возможных
ошибок в функции **febraryDays()**. Так, программа завершится, если 
**febraryDays()** вернет 30.

Другая, казалось бы, лишняя проверка, гарантирует, что длина среза всегда
будет равной 12:

```D
    assert(days.length == 12);
```

Таким образом, непреднамеренное добавление или удаление элементов в срезе 
также будет обнаружено. Такие проверки являются важным инструментом
обеспечения корректности программы.

**assert** также является фундаментальным инструментом юнит-тестирования и
контрактного программирования, которые будут рассмотрены в следующих главах.


# Никаких значений или побочных эффектов

Мы видели, что выражения порождают значения или имеют побочные эффекты.
Проверки **assert** не имеют значений и _не должны_ иметь побочных эффектов.

Язык D требует, чтобы оценка логического выражения не имела побочных эффектов. 
**assert** должен оставаться сторонним наблюдателем за состоянием программы.


## Отключение проверок **assert**

Поскольку **assert** отностится к корректности программы, его можно считать
ненужным, как только программа будет в достаточной степени протестирована.
Кроме того, так как **assert** не производит значений и побочных эффектов,
его удаление из программы не должно иметь никакого значения. 

Ключ компилятора **-release** заставляет его игнорировать проверки **assert**,
как если бы они никогда даже не были включены в программу:

    **dmd deneme.d -release

Это позволит программам работать быстрее, не оценивая потенциально медленные
проверки логических выражений в **assert**.

В качестве исключения, проверки **assert** с литеральным **false** (или 0) в
качестве логического выражения не отключаются даже при компиляции с флагом
**-release**. Это связано с тем, что **assert(false)** гарантирует, что блок
кода никогда не будет достигнут, и это условие должно выполняться даже в
релизных сборках.


## enforce для выбрасывания исключений

Не каждая непредвиденная ситуация является индикатором ошибки программы.
Программы могут получать неожиданный ввод или оказываться в неожиданном
состоянии среды выпонения. Например, данные, введенные пользователем, не
должны проверяться с помощью **assert**, поскольку неверные данные не имеют
ничего общего с корректностью самой программы. В данном случае уместо бросить
исключение, как мы делали в предыдущих программах.

**std.exception.enforce** - удобный способ бросать исключения. Например,
предположим, что при несоблюдении определенного условия должно быть брошено
исключение:

```D
    if (count < 3) {
        throw new Exception("Must be at least 3.");
    }
```

**enforce()** является оберткой вокруг проверки условия и инструкции 
**throw**.  Следующий код является эквивалентом предыдущего:

```D
import std.exception;
// ...
    enforce(count >= 3, "Must be at least 3.");
```

Обратите внимание, как логическое выражение отрицается по сравнению с
инструкцией **if**. Теперь оно выражает то, что _должно быть_.

## Как использовать

**assert** предназначен для обнаружения ошибок программиста.  
Защита утверждений, выполняемая **assert** в функции **monthDays()** и 
переменной **menuTitle** выше, касается ошибок программиста.

Иногда трудно решить, следует ли полагаться на проверку утверждений или 
выкидывать исключение. Решение должно основываться на том, возникла ли
непридвиденная ситуация из-за проблеммы, связанной с кодом программы.

В противном случае программа должна выкинуть исключение при невозможности 
выполнить задачу. **enforce()** является выразительным и удобным способом
сделать это. 

Еще один момент, который следует рассмотреть - имеется ли возможность каким-то 
образом устранить непредвиденную ситуацию. Если программа не может сделать 
никаких особенных действий, даже просто распечатать сообщение об ошибке с 
некоторыми входными данными, тогда уместно выбросить исключение. Таким образом
сторона, вызвавшая код, бросивший исключение, может отловить его и предпринять
какие-либо действия для восстановления из ошибочного состояния.


## Упражнения

1. Следующая программа содержит ряд проверок **assert**. Скомпилируйте и 
   запустите программу, чтобы обнаружить ее ошибки, выявляемые этими проверками.

   Программа получает от пользователя начальное время и продолжительность, и
   вычисляет конечное время, добавляя продолжительность к начальному времени:

    **10 hours and 8 minutes after 06:09 is 16:17.**

   Обратите внимание, что эту задача можно решить гораздо более простым
   способом, используя типы **struct**. Мы будем ссылаться на эту программу 
   в следующих главах.

    ```
    import std.stdio;
    import std.string;
    import std.exception;

    /* Reads the time as hour and minute after printing a
     * message. */
    void readTime(in string message,
                  out int hour,
                  out int minute) {
        write(message, "? (HH:MM) ");
    
        readf(" %s:%s", &hour, &minute);
    
        enforce((hour >= 0) && (hour <= 23) &&
                (minute >= 0) && (minute <= 59),
                "Invalid time!");
    }
    
    /* Returns the time in string format. */
    string timeToString(in int hour, in int minute) {
        assert((hour >= 0) && (hour <= 23));
        assert((minute >= 0) && (minute <= 59));
    
        return format("%02s:%02s", hour, minute);
    }
    
    /* Adds duration to start time and returns the result as the
     * third pair of parameters. */
    void addDuration(in int startHour, in int startMinute,
                     in int durationHour, in int durationMinute,
                     out int resultHour, out int resultMinute) {
        resultHour = startHour + durationHour;
        resultMinute = startMinute + durationMinute;
    
        if (resultMinute > 59) {
            ++resultHour;
        }
    }
    
    void main() {
        int startHour;
        int startMinute;
        readTime("Start time", startMinute, startHour);
    
        int durationHour;
        int durationMinute;
        readTime("Duration", durationHour, durationMinute);
    
        int endHour;
        int endMinute;
        addDuration(startHour, startMinute,
                    durationHour, durationMinute,
                    endHour, endMinute);
    
        writefln("%s hours and %s minutes after %s is %s.",
                 durationHour, durationMinute,
                 timeToString(startHour, startMinute),
                 timeToString(endHour, endMinute));
    }
    ```

   Запустите программу и введите **06:09** в качестве начального времени  
   и **1:2** в качестве продолжительности. Обратите внимание, что программа 
   завергается нормально.

   **Примечание:** мы можете заметить проблему с выводом. Пока ингнорируйте 
   её, так как далее вы обнаружите её при помощи **assert**.

2. Введите **06:09** и **15:2**. Наблюдайте, как программа завершится
   посредством AssertError. Перейдите в строку программы, указанную в 
   сообщении **assert** и посмотрите, какая из проверок дала сбой. Может 
   потребоваться некоторе время, чтобы обнаружить причину сбоя.

3. Ввкдите **06:09** и **20:0** и убедитесь, что та же проверка по прожнему
   дает сбой, пофиксите этот баг.

4. Измените программу, что бы она печатал время в 12-ти часовом формате и с
   индикаторами "am" и "pm".


[...решение](assert.cozum.html)

