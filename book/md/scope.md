# scope

Как мы видели в предыдущей главе, выражения, которые должны всегда
выполняться, записываются в блоке finally, и выражения, которые должны
выполнятся только при возникновении ошибок, записываются в блоках catch.

Можно сделать следующие замечания об использовании этих блоков:

- **catch** и **finally** не могут использоваться без блока **try**.

- Некоторые переменные, которые нужны в этих блокам, могут быть недоступны
  внутри них:
  
  ```D
    void foo(ref int r) {
        try {
            int addend = 42;

            r += addend;
            mayThrow();

        } catch (Exception exc) {
            r -= addend;           // ← ошибка копмиляции 
        }
    }
  ```
  
  Функция изменяет первый параметр-ссылку и пытается отменить эти изменения
  при возникновении исключения. К сожалению, **addend** доступен только в
  блоке **try**, где он определяется. (**Примечание:** _это связано с 
  областью видимости имен, и также временем жизни объекта, как будет
  объяснено в [последующих главах](lifetimes.html)._)

- Написание всех, потенциально не связанных, выражений в одном блоке
  **finally** внизу, отделяет их от кода, с которым они связаны.

Иснтрукция **scope** по функциональности схожа с инструкциями **catch** и
**finally**, но более удобна во многих аспектах. Подобно **finally**,
существет три разновидности **scope**, выполняющих выражения при выходе из
области видимости:

- **scope(exit):** выражение всегда выполняется при выходе из блока,  
  независимо от того, было ли это успешное завершение или через исключение.

- **scope(success):** выражение выполняется только при успешном завершении
  блока.

- **scope(failure):** выражение вполняется только при выходе из блока в 
  результате исключения.

Хотя эти иструкции тесно связаны с исключениями, их можно использовать без
блоков **try-catch**.

В качестве примера перепишем функцию выше с использованием **scope(failure)**:

```D
void foo(ref int r) {
    int addend = 42;

    r += addend;
    scope(failure) r -= addend;

    mayThrow();
}
```

Использование **scope(failure)** в этом примере гарантирует, что при выходе
из функции в результате возникновения исключения будет выполнено выражение
**r -= addend**. Преимущество **scope(failure)** в том, что теперь выражение,
отменяющее действие другого выражения, записано рядом с ним.

Инструкции для **scope** могут определяться в блоках:

```D
    scope(exit) {
        // ... expressions ...
    }
```

Вот другая функция, тестирующая все три типа инструкций:

```D
void test() {
    scope(exit) writeln("when exiting 1");

    scope(success) {
        writeln("if successful 1");
        writeln("if successful 2");
    }

    scope(failure) writeln("if thrown 1");
    scope(exit) writeln("when exiting 2");
    scope(failure) writeln("if thrown 2");

    throwsHalfTheTime();
}
```

При отсутствии исключений вывод функции включает только вывод **scope(exit)** 
и **scope(success)**:

    **when exiting 2
    if successful 1
    if successful 2
    when exiting 1**

Если возникло исключение, вывод включает вывод **scope(exit)** и
**scope(failure)**:

    **if thrown 2
    when exiting 2
    if thrown 1
    when exiting 1
    object.Exception@...: the error message**


Как видно, блоки инструкций **scope** выполняются в обратном порядке. Причина
в том, что более поздний код может зависеть от ранее используемых переменных.
Выполнение инструкций **scope** в обратном порядке позволяет отменить побочные
эффекты, которые могли бы возникнуть при выполнении выражений в
последовательном порядке.
