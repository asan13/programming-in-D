# Структуры

Как уже упоминалось в книге ранее, фундаментальные типы не подходят для
представления высокоуровневых концепций. Например, хотя значение типа **int**
подходит для представления часа дня, две связанных переменных **int** будут
более подходящими для представления момента времени: одга для часа, другая для
минуты.

Структуры позволяют определять новые типы путем комбинации уже существующих 
типов, используя для этого ключевое слово **struct**.  Соответственно,
струкруры являются _пользовательскими типами данных_.  Большая часть этой 
главы напрямую применима и к классам. В частности, концепция объединения 
существующих типов для определения нового типа для них совершенно одинакова.

В этой главе рассматриваются только основные особенности структур. Мы узнаем
больше о них в следующих главах:

- [Функции-члены](member_functions.html)
- [const ref параметры и функции-члены const](const_member_functions.html)
- [Конструкторы и другие специальные функции](special_functions.html)
- [Перегрузка операторов](operator_overloading.html)
- [Аттрибуты инкапсуляции и защиты](encapsulations.html)
- [Свойства](property.html)
- [Контрактное программирование для структур и классов](invariant.html)
- [foreach для структур и классов](foreach_opapply.html)

Чтобы понять, насколько полезны структуры, давайте посмотрим на функцию 
**addDuration()** из главы [assert и enforce](assert.html).  Вот её
определение из решения упражнений в этой главе:

```D
void addDuration(in int startHour, in int startMinute,
                 in int durationHour, in int durationMinute,
                 out int resultHour, out int resultMinute) {
    resultHour = startHour + durationHour;
    resultMinute = startMinute + durationMinute;
    resultHour += resultMinute / 60;

    resultMinute %= 60;
    resultHour %= 24;
}
```

_**Примечание** Далее для краткости я буду опускать **in**, **out** и 
**inittest**-блоки._

## Определение

Ключевое слово **struct** определяет новый тип путём объединения переменных, 
как-либо взаимосвязанных:

```D
struct TimeOfDay {
    int hour;
    int minute;
}
```

Здесь мы объявляем новый тип **TimeOfDay**, состоящий из двух переменных
**hour** и **minute**. Это позволяет использовать в программе новый тип, 
также как любой другой, например, **int**:

```D
    int number;            // переменная
    number = otherNumber;  // принимает значение otherNumber

    TimeOfDay time;        // объект
    time = otherTime;      // принимает значение otherTime
```

Синтаксис:

```D
struct TypeName {
    // ... члены - переменные и фукции ...
}
```

Функции-члены мы рассмотрим с следующих главах.

Переменные, объединяемые структурой, называются _членами_. В
соответствии с этим определением, **TimeOfDay** имеет два члена: **hour** и
**minute**.

## struct определяет тип, не переменную

Это важное различие: после чтения глав [Область видимости](name_scope.html)
и [Время жизни и фундаментальные операции](lifetimes.html) может возникнуть 
впечатление, что фигурные скобки в определении структуры задают область, в 
которой начинают и заканчивают свое существование члены структуры. Это не так.

Определение членов не является определением переменных:

```D
struct TimeOfDay {
    int hour;      // ← Не переменная; станет частью переменной struct
                   //   в программе

    int minute;    // ← Не переменная; станет частью переменной struct
                   //   в программе

}
```

Объявление **struct** определяет имена и типы членов, которые будут иметь 
объекты этой структуры. Эти переменные-члены будут сконструированы, как части
объектов **TimeOfDay**, которые используются в программе:

```D
    TimeOfDay bedTime;    // Объект содержит собственные переменные-члены
                          // hour и minute.

    TimeOfDay wakeUpTime; // Также собственные переменные-члены, не
                          // связанные с переменными предыдущего объекта.
```

Переменные типов **struct** и **class** называются объектами.

## Удобство кодирования

Возможность сочетать понятия часа и минуты в новом типе очень удобно.
Например, можно написать более выразительную версию приведенной выше функции, 
используя три параметра типа **TimeOfDay** вместо шести параметров **int**:

```D
void addDuration(in TimeOfDay start,
                 in TimeOfDay duration,
                 out TimeOfDay result) {
    // ...
}
```

_**Примечание:** Как правило, неверно использовать две переменные для 
представления двух моментов времени. Не имеет смысла добавлять время обеда,
12:00, к времени завтрака, 7:30. Разумнее определить другой тип,
соответсвенно названный **Duration**, и использовать объекты этого типа в
операции сложения с объектами **TimeOdDay**. Несмотря на этот архитектурный 
изъян, я продолжу использовать объекты типа **TimeOfDay** в этой главе и 
введу тип **Duration** в следующей._

Как вы помните, функции возвращают единственное значение. Именно по этому
более раннее определение **addDuration()** содержало два **out**-параметра -
нельзя вернуть информацию о часе и минуте в одном значении.

Структуры убирают это ограничение - поскольку множество значений можно 
объединить в **struct**, функция может возвращать объект этого типа,
фaктически возращая сразу несколько значений за раз. **addDuration()** 
можно определить так, с возвратом результата:

```D
TimeOfDay addDuration(in TimeOfDay start,
                      in TimeOfDay duration) {
    // ...
}
```

Как следствие, **addDuration()** превращается в функцию, производящую
значение, вместо функции с побочными эффектами. Как вы помните из главы
[Функции](functions.html), производство результата предпочтительней наличия
побочных эффектов.

Структуры могут быть членами других структур. Например, следующая структура
имеет два члена **TimeOdDay**:

```D
struct Meeting {
    string    topic;
    size_t    attendanceCount;
    TimeOfDay start;
    TimeOfDay end;
}
```

В свою очередь, **Meeting** может быть членом другой структуры.  Допустим, 
существует также структура **Meal**:

```D
struct DailyPlan {
    Meeting projectMeeting;
    Meal    lunch;
    Meeting budgetMeeting;
}
```

## Доступ к членам

Члены структуры используются также, как другие переменные. Единственная
разница между ними в том, что в действительности они переменные структуры и
перед именем нужно указывать _точку_:

```D
    start.hour = 10;
```

Выше значение 10 присваивается члену **hour** объекта **start**.

Перепишем **addDuration()** с учетом того новых знаний:

```D
TimeOfDay addDuration(in TimeOfDay start,
                      in TimeOfDay duration) {
    TimeOfDay result;

    result.minute = start.minute + duration.minute;
    result.hour = start.hour + duration.hour;
    result.hour += result.minute / 60;

    result.minute %= 60;
    result.hour %= 24;

    return result;
}
```

Обратите внимание, что имена переменных в этой версии стали намного короче:
**start**, **duration** и **result**. Кроме того, вместо использования сложных 
имен, таких как **startHour**, мы получаем доступ к элементам структуры через 
соответствующие переменные, как в **start.hour**, например.

Пример кода, использующий новую версию **addDuration()**, в котором задаётся 
начало и продолжительность урока и определяется конец урока:

```D
void main() {
    TimeOfDay periodStart;
    periodStart.hour = 8;
    periodStart.minute = 30;

    TimeOfDay periodDuration;
    periodDuration.hour = 1;
    periodDuration.minute = 15;

    immutable periodEnd = addDuration(periodStart,
                                      periodDuration);

    writefln("Period end: %s:%s",
              periodEnd.hour, periodEnd.minute);
}
```

Результат:

    Period end: 9:45

Функция **main()** в примере использует только рассмотренные на данный момент 
возможности. Далее мы сделаем этот код намного короче и чище.


## Конструирование

В функции **main()** выше, в первых трех строках конструируется объект 
**periodStart** и в следующих трех строках объект **periodDuration**.  В обоих 
кусках кода вначале определяется объект и затем устанавливаются значения часов 
и минут.

Для того, что бы переменная могла использоваться безопасным образом, сначала
она должна быть сконструирована в согласованном состоянии. Поскольку
конструирование используется постоянно, существует специальный синтаксис для
конструирования объектов структур:

```D
    TimeOfDay periodStart = TimeOfDay(8, 30);
    TimeOfDay periodDuration = TimeOfDay(1, 15);
```

Значения автоматически присваиваются членам, в том порядке, в котором они
встречаются в определении: 
Поскольку в **struct** **hour** объявлена первой, **periodStart.hour** 
присваивается 8, и **periodStart.minute** - 30.

Как мы узнали в главе [Преобразование типов](cast.html), синтаксис
конструирования можно использовать и с другими типами:

```D
    auto u = ubyte(42);    // u - ubyte
    auto i = int(u);       // i - int
```

### Создание **immutable** объектов

Возможность создания объекта путем указания значений его членов так же 
позволяет определять объекты, как **immutable**:

```D
    immutable TimeOfDay periodStart;
    periodStart.hour = 8;      // ← compilation ERROR
    periodStart.minute = 30;   // ← compilation ERROR
```

#### Можно пропускать оставшиеся члены

Можно задавать меньше значений, чем число членов. В этом случае оставшиеся
члены инициируются значением **.init** соответствующего типа.

Следующая программа создает объекты **Test**, с каждым разом передавая в
конструтор меньшее число параметров. **assert** показывает, что не
определенные члены автоматически инициализируются значениями своего **.init**.
(Причина, по которой нужно  вызвать **isNaN()**, объясняется после программы):

```D
import std.math;

struct Test {
    char   c;
    int    i;
    double d;
}

void main() {
    // Определены начальные значения для всех членов
    auto t1 = Test('a', 1, 2.3);
    assert(t1.c == 'a');
    assert(t1.i == 1);
    assert(t1.d == 2.3);

    // Пропущен последний
    auto t2 = Test('a', 1);
    assert(t2.c == 'a');
    assert(t2.i == 1);
    assert(isNaN(t2.d));

    // Пропущены два последних
    auto t3 = Test('a');
    assert(t3.c == 'a');
    assert(t3.i == int.init);
    assert(isNaN(t3.d));

    // Начальные значения не заданы
    auto t4 = Test();
    assert(t4.c == char.init);
    assert(t4.i == int.init);
    assert(isNaN(t4.d));

    // Аналогично
    Test t5;
    assert(t5.c == char.init);
    assert(t5.i == int.init);
    assert(isNaN(t5.d));
}
```

Из главы [Типы с плавающей точкой](floating_point.html) известно, что тип
**double** инициируется значением **double.nan**. Значение **.nan**
_неупорядочено_, что не позволяет использовать его в операциях сравнения. По
этой причине правильным способом проверки значения на равенство **.nan**
является использование **std.math.isNaN**. 

#### Определение значений по умолчанию для членов

Важно, что переменные-члены автоматически инициализируются известными
начальными значениями. Это не позволяет программе выполняться с
неопределёнными значениями. Тем не менее, значение **.init** соответствующих
типов может не подходить для каждого типа. Например, **char.init** даже не
является допустимым.

Начальные значения членов можно указывать при определении структуры. Это
полезно, например, чтобы инициализировать члены с типом числа с плавающей
точкой значением **0.0** вместо обычно непригодного **.nan**.

Для определения значений по умолчанию используется синтаксис присваивания при
объявлении члена:

```D
struct Test {
    char   c = 'A';
    int    i = 11;
    double d = 0.25;
}
```

Обратите внимание, что, несмотря на синтаксис, это не реальное присваивание.
Здесь просто определяются значения по умолчанию, которые будут использоваться
при фактическом создании объектов позже. 

Например, здесь объект **Test** создается без задаваемых значений:

```D
    Test t;  // Значения членов не определяются 
    writefln("%s,%s,%s", t.c, t.i, t.d);
```

Все члены инициализируются значениями по умолчанию:

    A,11,0.25


#### Конструирование через синтаксис {}

Структуры можно конструировать с использованием следующего синтаксиса:

```D
    TimeOfDay periodStart = { 8, 30 };
```

Так же, как в ранее рассмотренном синтаксисе, указанные значения присваиваются
членам в порядке их определения. Члены, определённые ближе к концу, получают
свои значения по умолчанию.

Этот синтаксис унаследован от языка программироания C:

```D
    auto periodStart = TimeOfDay(8, 30);    // ← нормальный
    TimeOfDay periodEnd = { 9, 30 };        // ← C-стиль
```

Этот синтаксис позволяет также _обозначать инициализаторы_. Обозначенные
инициализаторы указывают элемент, с которым связано значение инициализации.
Можно даже инициализировать элементы в порядке, отличном от того, в котором
они определены в структуре:

```D
TimeOfDay t = { minute: 42, hour: 7 };
```

## Копирование и присваивание

Структуры являются типами-значениями. Как описано в главе [Типы-значения и
ссылочные типы](values_vs_references.html), это значит, что каждый объект
структуры имеет собственное значение. Объекты получают свои значения при
создании, и меняют их при присаивании им новых значений.

```D
    auto yourLunchTime = TimeOfDay(12, 0);
    auto myLunchTime = yourLunchTime;

    // Only my lunch time becomes 12:05:
    myLunchTime.minute += 5;

    // ... your lunch time is still the same:
    assert(yourLunchTime.minute == 0);
```

При копировании все члены исходного автоматически копируются в
соответствующие члены целевого объекта. Аналогичной процесс происходит при
присваивании.

Члены структуры, являющиеся ссылками, требуют дополнительной заботы.

### Проявляйте осторожность с членами ссылочных типов!

Как вы помните, копировыние или присваивание ссылочных типов не меняет никаких
значений, оно меняет то, на какой объект ссылается переменная. В результате,
копирование или присваивание ненерирует еще одну ссылку на правостронний 
объект. Уместность этого для членов структуры определяется тем, что члены 
двух отдельных объектов структуры начнут предоставлять доступ к одному и тому 
же значению.

Рассмотрим это на примере структуры, в которой один из членов является
ссылочным типом. Структура хранит номер студента и его оценки:

```D
struct Student {
    int number;
    int[] grades;
}
```

Сконструируем второй объект **Student**, скопировав существующий:

```D
    // Конструируем первый объект:
    auto student1 = Student(1, [ 70, 90, 85 ]);

    // Конструируем второй объект, скопировав первый
    // и поменяем номер студента:
    auto student2 = student1;
    student2.number = 2;

    // ПРЕДУПРЕЖДЕНИЕ: Теперь оценки разделяются обеими объектами!

    // Изменение оценок первого студента ...
    student1.grades[0] += 5;

    // ... также затрагивает второго студента:
    writeln(student2.grades[0]);
```

После конструирования **student2** его члены получают значение членов
**student1**. **int** является объектом-значением, поэтому второй объект
получает собственное значение **number**.

Два объекта **Student** также имеют индивидуальные члены **grades**. Однако,
поскольку срезы являются ссылочными типами, фактически эти два среза разделяют
одинаковые элементы. Соответсвенно, изменение одного среза видимо в другом
срезе.

Вывод данного кода показывает, что у второго студента оценки также изменились:

    75

Поэтому лучшим подходом к конструированию второго объекта будет копирование
оценок первого:

```D
    // Второй Student конструируется с созданием копий оценок первого:
    auto student2 = Student(2, student1.grades.dup);

    // Изменение оценок первого студента ...
    student1.grades[0] += 5;

    // ... не влияет на оценки второго:
    writeln(student2.grades[0]);
```

Поскольку в этот раз **.dup** сделал копию оценок, у второго студента оценки 
не изменились:

    70

_Примечание: возможно осуществлять автоматическое копирование членов-ссылок.
Мы увидим, как это сделать, при рассмотрении функций-членов структуры._


## Литералы структур

Для литеральные значения, типа целочисленного 10, не нужно определять
переменную, что бы использовать их в выражении. Так же могут использоваться
литералы структур.

Литералы структур конструируются с использованием синтаксиса создания объекта:

```D
    TimeOfDay(8, 30) // ← Литеральное значение структуры
```

Давайте перепишем функцию **main()** с использованием новых знаний. Переменные
конструируются с использованием синтаксиса конструирования и в этой версии они
**immutable**:

```D
void main() {
    immutable periodStart = TimeOfDay(8, 30);
    immutable periodDuration = TimeOfDay(1, 15);

    immutable periodEnd = addDuration(periodStart,
                                      periodDuration);

    writefln("Period end: %s:%s",
              periodEnd.hour, periodEnd.minute);
}
```

Обратите внимание, что в этой простой программе  нет нужды определять 
именованные переменные **periodStart** и **periodDuration**. Фактически, это 
временные переменные, нужные только для вычисления сзначения переменной
**зукшщвУтв**. Вместо этого их можно передать в **addDuration()**, как
литералы:

```D
void main() {
    immutable periodEnd = addDuration(TimeOfDay(8, 30),
                                      TimeOfDay(1, 15));

    writefln("Period end: %s:%s",
              periodEnd.hour, periodEnd.minute);
}
```

## static члены

Хотя, в основном, объектам нужны индивидуальные копии членов структуры, для
объектов некоторых структур иногда имеет смысл делиться некоторыми
переменными. Может потребоаться, например, поддерживать общую для данного типа
структуры информацию.

Представим тип, присваивающий собственный идентификатор каждому создаваемому
объекту:

```D
struct Point {
    // Идентификатор для каждого объекта 
    size_t id;

    int line;
    int column;
}
```

Что бы можно было присваивать различные id объектам, нужна отдельная 
переменная для хранения следующего доступного id, значение которой будет
увеличиваться каждый раз при создании объекта. Допустим, что где-либо 
определена переменная **nextId**, доступная в следующей функции:

```D
Point makePoint(int line, int column) {
    size_t id = nextId;
    ++nextId;

    return Point(id, line, column);
}
```

Теперь нужно где-то определить эту общую переменную. В подобных случаях хорошо
подходят **static**-члены.

Такая общая информация определяется, как **статический** член структуры. В
отличии от обычных членов, для каждого статического существует только одна
переменная на поток. (Обратите внимание, что большинство программ состоит из
единственного потока, запускающего функцию **main()**.) Эта единственная
переменная разделяется всеми объектами данной структуры в данном потоке:

```D
import std.stdio;

struct Point {
    // The identifier of each object
    size_t id;

    int line;
    int column;

    // The id of the next object to construct
    static size_t nextId;
}

Point makePoint(int line, int column) {
    size_t id = Point.nextId;
    ++Point.nextId;

    return Point(id, line, column);
}

void main() {
    auto top = makePoint(7, 0);
    auto middle = makePoint(8, 0);
    auto bottom =  makePoint(9, 0);

    writeln(top.id);
    writeln(middle.id);
    writeln(bottom.id);
}
```

Так как **nextId** увеличивается всякий раз при создании объекта, каждый
объект получает уникальный id:

    0
    1
    2

Так как владельцем **static**-члена является тип в целом, для доступа к нему
не нужен объект. Выше мы видим, что к таким членам можно обращаться как с
использованием имени типа, так и через любой объект этого типа:

```D
    ++Point.nextId;
    ++bottom.nextId;    // тоже самое
```

Если переменная должна быть единой не для одного _треда_, а для всей 
_программы_, она должна быть объеявлена, как **shared static**. Ключевое слово
**shared** мы рассмотрим позже.


## Использование static this() для инициализации, и static ~this() для финализации

Вместо явного присваивания начального значения переменной **nextId** из
примера выше, мы полагаемся на начальное значение по кмолчанию - ноль. Мы
могли бы использовать любое другое значение:

```D
    static size_t nextId = 1000;
```

Это возможно, однако, только если начальное значение известно во время
компиляции. Кроме того, может потребоавться выполнить како-либо код до того,
как структура может быть использована потоком. Такой код записывается в
границах **static this()**.

Например, прочитаем начальное значение из файла:

```D
import std.file;

struct Point {
// ...

    enum nextIdFile = "Point_next_id_file";

    static this() {
        if (exists(nextIdFile)) {
            auto file = File(nextIdFile, "r");
            file.readf(" %s", &nextId);
        }
    }
}
```

Содержимое блоков **static this()** автоматически выполняется единожды для 
потока еще до того, как **struct**-тип может быть использован в потоке. Код,
который нужно выполнить один раз для всей программы (например, инициализация
**shared** или **immutable** переменных) должен быть помещен в блоки 
**shared static this()** и **shared static ~this()**, которые мы рассмотрим в
главе [Параллельное совместное использование данных](concurrency_shared.html).

Аналогичным образом, **static ~this()** выполняется при завершении потока, и 
**shared static ~this()** при завершении программы.

В следующем примере мы дополняем предыдущий пример для **static this()** и 
сохраняем значение **nextId** в том же файле, эффективно сохраняя
идентификаторы объектов между последовательными запусками программы:

```D
struct Point {
// ...

    static ~this() {
        auto file = File(nextIdFile, "w");
        file.writeln(nextId);
    }
}
```

Теперь программа инициализирует **nextId** значением, которое переменная имела
на момент остановки программы. Так, при второй запуске получим:

    3
    4
    5

## Примеры

1. Разработайте структуру **Card**, представляющую игральную карту.

   Структура может иметь два члена для представления масти и значения карты.
   Возможно стоит еспользовать **enun** для представления масти, либо просто
   использовать символы ♠, ♡, ♢ и ♣.
   
   Для значения карты можно испольовать **int** или **dchar**. Если вы решите 
   использовать int, значения 1, 11, 12 и 13 могут представлять карты, у которых 
   нет номеров (туз, вылет, дама и король).
   
   Есть и другие варианты дизайна. Например, использовать **enum** и для значений
   карт. 
   
   Способ конструирования объектов этой структуры будет зависеть от выбора типов
   для её членов. Например, если оба члена будут иметь тип **dchar**, создание
   объекта будет выглядеть примерно так:
   
   ```D
       auto card = Card('♣', '2');
   ```
2. Определите функцию **printCard()**, принимающую объект **Card** в качестве
   параметра и просто печатающее его:

   ```D
   struct Card {
    // ... определите структуру ...
   }
   
   void printCard(in Card card) {
       // ... напишите тело функции ...
   }
   
   void main() {
       auto card = Card(/* ... */);
       printCard(card);
   }
   ```
   
   Например, так функция могла бы печатать двойку треф:

       ♣2
    
   Реализация функции зависит от типов членов структуры.

3. Определите функцию с именем **newDeck()**, возвращающую колоду из 52 карт
   в виде среза из элементов типа **Card**:

   ```D
    Card[] newDeck()
    out (result) {
        assert(result.length == 52);

    } body {
        // ... напишите тело функции ...
    }
   ```
   
   Пример кода, вызывающего **newDeck()**, должен работать:

   ```
        Card[] deck = newDeck();

        foreach (card; deck) {
            printCard(card);
            write(' ');
        }

        writeln();
   ```

   Результат работы должен быть примерно таким, с 52 различными картами:

       ♠2 ♠3 ♠4 ♠5 ♠6 ♠7 ♠8 ♠9 ♠0 ♠J ♠Q ♠K ♠A ♡2 ♡3 ♡4
       ♡5 ♡6 ♡7 ♡8 ♡9 ♡0 ♡J ♡Q ♡K ♡A ♢2 ♢3 ♢4 ♢5 ♢6 ♢7
       ♢8 ♢9 ♢0 ♢J ♢Q ♢K ♢A ♣2 ♣3 ♣4 ♣5 ♣6 ♣7 ♣8 ♣9 ♣0
       ♣J ♣Q ♣K ♣A

4. Напишите функцию, перемешивающую колоду. Один из способов - выбрать две 
   карты в случайном порядке с помощью **std.random.uniform** и поменять их 
   местами; повторить этот процесс достаточное количество раз. Функция должна
   принимать число повторов в виде параметра:

   ```D
    void shuffle(Card[] deck, in int repetition) {
        // ... напишите тело функции ...
    }
   ```

   Пример использования функции:

   ```D
        Card[] deck = newDeck();
        shuffle(deck, 1);

        foreach (card; deck) {
            printCard(card);
            write(' ');
        }

        writeln();
   ```
   
   Функция должна менять карты местами **repition** раз. Например, если
   вызвать её с 1, вывод должен быть примерно следующим:

        ♠2 ♠3 ♠4 ♠5 ♠6 ♠7 ♠8 ♠9 ♠0 ♠J ♠Q ♠K ♠A ♡2 ♡3 ♡4
        ♡5 ♡6 ♡7 ♡8 ♣4 ♡0 ♡J ♡Q ♡K ♡A ♢2 ♢3 ♢4 ♢5 ♢6 ♢7
        ♢8 ♢9 ♢0 ♢J ♢Q ♢K ♢A ♣2 ♣3 ♡9 ♣5 ♣6 ♣7 ♣8 ♣9 ♣0
        ♣J ♣Q ♣K ♣A
   
   Более высокое значение **repetion** приводит к лучше перемешанной колоде:

   ```D
        shuffled(deck, 100);
   ```

   Результат:

        ♠4 ♣7 ♢9 ♢6 ♡2 ♠6 ♣6 ♢A ♣5 ♢8 ♢3 ♡Q ♢J ♣K ♣8 ♣4
        ♡J ♣Q ♠Q ♠9 ♢0 ♡A ♠A ♡9 ♠7 ♡3 ♢K ♢2 ♡0 ♠J ♢7 ♡7
        ♠8 ♡4 ♣J ♢4 ♣0 ♡6 ♢5 ♡5 ♡K ♠3 ♢Q ♠2 ♠5 ♣2 ♡8 ♣A
        ♠K ♣9 ♠0 ♣3

   _**Примечание:** В решениях к задачам демонстрируется гораздо лучший способ
   перемешивания колоды._

[... решения](http://ddili.org/ders/d.en/struct.cozum.html)
