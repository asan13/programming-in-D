# Структуры

Как уже упоминалось в книге ранее, фундаментальные типы не подходят для
представления высокоуровневых концепций. Например, хотя значение типа **int**
подходит для представления часа дня, две связанных переменных **int** будут
более подходящими для представления момента времени: одга для часа, другая для
минуты.

Структуры позволяют определять новые типы путем комбинации уже существующих 
типов, используя для этого ключевое слово **struct**.  Соответственно,
струкруры являются _пользовательскими типами данных_.  Большая часть этой 
главы напрямую применима и к классам. В частности, концепция объединения 
существующих типов для определения нового типа для них совершенно одинакова.

В этой главе рассматриваются только основные особенности структур. Мы узнаем
больше о них в следующих главах:

- [Функции-члены](member_functions.html)
- [const ref параметры и функции-члены const](const_member_functions.html)
- [Конструкторы и другие специальные функции](special_functions.html)
- [Перегрузка операторов](operator_overloading.html)
- [Аттрибуты инкапсуляции и защиты](encapsulations.html)
- [Свойства](property.html)
- [Контрактное программирование для структур и классов](invariant.html)
- [foreach для структур и классов](foreach_opapply.html)

Чтобы понять, насколько полезны структуры, давайте посмотрим на функцию 
**addDuration()** из главы [assert и enforce](assert.html).  Вот её
определение из решения упражнений в этой главе:

```D
void addDuration(in int startHour, in int startMinute,
                 in int durationHour, in int durationMinute,
                 out int resultHour, out int resultMinute) {
    resultHour = startHour + durationHour;
    resultMinute = startMinute + durationMinute;
    resultHour += resultMinute / 60;

    resultMinute %= 60;
    resultHour %= 24;
}
```

_**Примечание** Далее для краткости я буду опускать **in**, **out** и 
**inittest**-блоки._

## Определение

Ключевое слово **struct** определяет новый тип путём объединения переменных, 
как-либо взаимосвязанных:

```D
struct TimeOfDay {
    int hour;
    int minute;
}
```

Этот код определяет новый тип **TimeOfDay**, состоящий из двух переменных
**hour** и **minute**. Это определение позволяет использовать в программе этот 
новый тип, также как любой другой тип, например, **int**:

```D
    int number;            // переменная
    number = otherNumber;  // принимает значение otherNumber

    TimeOfDay time;        // объект
    time = otherTime;      // принимает значение otherTime
```

Синтакси объявления **struct**:

```D
struct TypeName {
    // ... члены - переменные и фукции ...
}
```

Функции-члены мы рассмотрим с следующих главах.

Переменные, объединяемые вместе структурой, называются _членами_. В
соответствии с этим определением, **TimeOfDay** имеет два члена: **hour** и
**minute**.

## struct определяет тип, а не переменную

Это важное различие: В частности, после глав [Область видимости](name_scope.html)
и [Время жизни и фундаментальные операции](lifetimes.html) может возникнуть
неверное впечатление, что фигурные скобки в определении структуры определяют
область, в которой начинают и заканчивают свое существование члены структуры.
Это не так.

Определение членов не является определением переменных:

```D
struct TimeOfDay {
    int hour;      // ← Не переменная; станет частью переменной struct,
                   //   используемой в программе

    int minute;    // ← Не переменная; станет частью переменной struct,
                   //   используемой в программе

}
```
Объявление **struct** определяет типы и имена членов, которые будут иметь 
объекты этой структуры. Эти переменные-члены будут сконструированы, как части
объектов **TimeOfDay**, задействованных в программе:

```D
    TimeOfDay bedTime;    // Этот объект содержит собственные переменные-члены
                          // hour и minute.

    TimeOfDay wakeUpTime; // Также сожержит собственные переменные-члены, не
                          // связанные с переменными предыдущего объекта.
```

Переменные типов **struct** и **class** называются объектами.

## Удобство кодирования

Возможность сочетать понятия часа и минуты в новом типе очень удобно.
Например, можно написать более выразительную версию приведенной выше функции, 
используя три параметра типа **TimeOfDay** вместо шести параметров типа 
**int**:

```D
void addDuration(in TimeOfDay start,
                 in TimeOfDay duration,
                 out TimeOfDay result) {
    // ...
}
```

_**Примечание:** Добавлять две переменные для представления двух моментов 
времени, обычно, неправильно. Например, немного смысла добавлять время обеда,
12:00, к времени завтрака, 7:30. Было бы разумнее определить другой тип,
соответсвенно названный **Duration**, и добавлять объекты этого типа к
объектам **TimeOdDay**. Несмотря на это архитектурный изъян, в этой главе я
продолжу использовать только объекты **TimeOfDay** и введу **Duration** в
следующей._

Как вы помните, функции возвращают единесвенное значение. Именно по этой
причине раннее определение **addDuration()** содержало два прпаметра **out** -
нельзя вернуть информацию о часе и минуте единственным значением.

Структуры избавляют от данного ограничения - поскольку множество значений 
можно объединить в **struct**-тип, функция может возвращать объект этого типа,
фaктически возращая сразу несколько значений за раз. **addDuration()** теперь
можно определить, как возвращающую свой результат:

```D
TimeOfDay addDuration(in TimeOfDay start,
                      in TimeOfDay duration) {
    // ...
}
```

Как следствие, **addDuration()** превращается в функцию, производящую
значение, вместо функции с побочными эффектами. Как вы помните из главы
[Функции](functions.html), производство результата предпочтительней наличия
побочных эффектов.

Структуры могут быть членами других структур. Например, следующая структура
имеет два члена **TimeOdDay**:

```D
struct Meeting {
    string    topic;
    size_t    attendanceCount;
    TimeOfDay start;
    TimeOfDay end;
}
```

В свою очередь, **Meeting** может быть членом другой структуры.  Допустим, 
существует также структура **Meal**:

```D
struct DailyPlan {
    Meeting projectMeeting;
    Meal    lunch;
    Meeting budgetMeeting;
}
```

## Доступ к членам

Члены структуры используются также, как другие переменные. Единственная
разница между ними в том, что в действительности они переменные структуры и
перед именем члена нужно указывать _точку_:

```D
    start.hour = 10;
```

Выше мы присваиваем значение 10 члену **hour** объекта **start**.

Перепишем **addDuration()** с учетом того, что мы узнали:

```D
TimeOfDay addDuration(in TimeOfDay start,
                      in TimeOfDay duration) {
    TimeOfDay result;

    result.minute = start.minute + duration.minute;
    result.hour = start.hour + duration.hour;
    result.hour += result.minute / 60;

    result.minute %= 60;
    result.hour %= 24;

    return result;
}
```

Обратите внимание, что имена переменных в этой версии стали намного короче:
**start**, **duration** и **result**. Кроме того, вместо использования сложных 
имен, таких как **startHour**, мы получаем доступ к элементам структуры через 
соответствующие переменные, как в **start.hour**, например.

Пример кода, использующий новую версию **addDuration()**. Задавая время начала
и продолжительность урока, он определяет, когда заканчивается урок:

```D
void main() {
    TimeOfDay periodStart;
    periodStart.hour = 8;
    periodStart.minute = 30;

    TimeOfDay periodDuration;
    periodDuration.hour = 1;
    periodDuration.minute = 15;

    immutable periodEnd = addDuration(periodStart,
                                      periodDuration);

    writefln("Period end: %s:%s",
              periodEnd.hour, periodEnd.minute);
}
```

Выводит:

    Period end: 9:45

Функция **main()** в примере написана, используя только рассмотренные на 
данный момент возможности. Далее мы сделаем этот код намного короче и чище.


## Конструирование

В функции **main()** выше, в первых трех строках конструируется объект 
**periodStart** и в следующих трех строках объект **periodDuration**.  В обоих 
кусках кода вначале определяется объект и затем устанавливаются значения часов 
и минут.

Для того, что бы переменная могла использоваться безопасным образом, сначала
она должна быть сконструирована в согласованном состоянии. Поскольку
конструирование используется постоянно, существует специальный синтаксис для
конструирования объектов структур:

```D
    TimeOfDay periodStart = TimeOfDay(8, 30);
    TimeOfDay periodDuration = TimeOfDay(1, 15);
```

Значения автоматически присваиваются членам, в том порядке, в котором они
встречаются в определении: 
Поскольку в **struct** **hour** объявлена первой, **periodStart.hour** 
присваивается 8, и **periodStart.minute** - 30.

Как мы узнали в главе [Преобразование типов](cast.html), синтаксис
конструирования можно использовать и с другими типами:

```D
    auto u = ubyte(42);    // u - ubyte
    auto i = int(u);       // i - int
```

### Создание **immutable** объектов

Возможность создания объекта путем указания значений его членов так же 
позволяет определять объекты, как **immutable**:

```D
    immutable TimeOfDay periodStart;
    periodStart.hour = 8;      // ← compilation ERROR
    periodStart.minute = 30;   // ← compilation ERROR
```

#### Можно пропускать оставшиеся члены

Можно задавать меньше значений, чем число членов. В этом случае оставшиеся
члены инициируются значением **.init** соответствующего типа.

Следующая программа создает объекты **Test**, с каждым разом передавая в
конструтор меньшее число параметров. **assert** показывает, что не
определенные члены автоматически инициализируются значениями своего **.init**.
(Причина, по которой нужно  вызвать **isNaN()**, объясняется после программы):

```D
import std.math;

struct Test {
    char   c;
    int    i;
    double d;
}

void main() {
    // Определены начальные значения для всех членов
    auto t1 = Test('a', 1, 2.3);
    assert(t1.c == 'a');
    assert(t1.i == 1);
    assert(t1.d == 2.3);

    // Пропущен последний
    auto t2 = Test('a', 1);
    assert(t2.c == 'a');
    assert(t2.i == 1);
    assert(isNaN(t2.d));

    // Пропущены два последних
    auto t3 = Test('a');
    assert(t3.c == 'a');
    assert(t3.i == int.init);
    assert(isNaN(t3.d));

    // Начальные значения не заданы
    auto t4 = Test();
    assert(t4.c == char.init);
    assert(t4.i == int.init);
    assert(isNaN(t4.d));

    // Аналогично
    Test t5;
    assert(t5.c == char.init);
    assert(t5.i == int.init);
    assert(isNaN(t5.d));
}
```

Из главы [Типы с плавающей точкой](floating_point.html) известно, что тип
**double** инициируется значением **double.nan**. Значение **.nan**
_неупорядочено_, что не позволяет использовать его в операциях сравнения. По
этой причине правильным способом проверки значения на равенство **.nan**
является использование **std.math.isNaN**. 

#### Определение значений по умолчанию для членов

Важно, что переменные-члены автоматически инициализируются известными
начальными значениями. Это не позволяет программе выполняться с
неопределёнными значениями. Тем не менее, значение **.init** соответствующих
типов может не подходить для каждого типа. Например, **char.init** даже не
является допустимым.

Начальные значения членов можно указывать при определении структуры. Это
полезно, например, чтобы инициализировать члены с типом числа с плавающей
точкой значением **0.0** вместо обычно непригодного **.nan**.

Для определения значений по умолчанию используется синтаксис присваивания при
объявлении члена:

```D
struct Test {
    char   c = 'A';
    int    i = 11;
    double d = 0.25;
}
```

Обратите внимание, что, несмотря на синтаксис, это не реальное присваивание.
Здесь просто определяются значения по умолчанию, которые будут использоваться
при фактическом создании объектов позже. 

Например, здесь объект **Test** создается без задаваемых значений:

```D
    Test t;  // Значения членов не определяются 
    writefln("%s,%s,%s", t.c, t.i, t.d);
```

Все члены инициализируются значениями по умолчанию:

    A,11,0.25


#### Конструирование через синтаксис {}

Структуры можно конструировать с использованием следующего синтаксиса:

```D
    TimeOfDay periodStart = { 8, 30 };
```

Так же, как в ранее рассмотренном синтаксисе, указанные значения присваиваются
членам в порядке их определения. Члены, определённые ближе к концу, получают
свои значения по умолчанию.

Этот синтаксис унаследован от языка программироания C:

```D
    auto periodStart = TimeOfDay(8, 30);    // ← нормальный
    TimeOfDay periodEnd = { 9, 30 };        // ← C-стиль
```

Этот синтаксис позволяет также _обозначать инициализаторы_. Обозначенные
инициализаторы указывают элемент, с которым связано значение инициализации.
Можно даже инициализировать элементы в порядке, отличном от того, в котором
они определены в структуре:

```D
TimeOfDay t = { minute: 42, hour: 7 };
```

## Копирование и присваивание

Структуры являются типами-значениями. Как описано в главе [Типы-значения и
ссылочные типы](values_vs_references.html), это значит, что каждый объект
структуры имеет собственное значение. Объекты получают свои значения при
создании, и меняют их при присаивании им новых значений.

```D
    auto yourLunchTime = TimeOfDay(12, 0);
    auto myLunchTime = yourLunchTime;

    // Only my lunch time becomes 12:05:
    myLunchTime.minute += 5;

    // ... your lunch time is still the same:
    assert(yourLunchTime.minute == 0);
```

При копировании все члены исходного автоматически копируются в
соответствующие члены целевого объекта. Аналогичной процесс происходит при
присваивании.

Члены структуры, являющиеся ссылками, требуют дополнительной заботы.

### Проявляйте осторожность с членами ссылочных типов!

Как вы помните, копировыние или присваивание ссылочных типов не меняет никаких
значений, оно меняет то, на какой объект ссылается переменная. В результате,
копирование или присваивание ненерирует еще одну ссылку на правостронний 
объект. Уместность этого для членов структуры определяется тем, что члены 
двух отдельных объектов структуры начнут предоставлять доступ к одному и тому 
же значению.

Рассмотрим это на примере структуры, в которой один из членов является
ссылочным типом. Структура хранит номер студента и его оценки:

```D
struct Student {
    int number;
    int[] grades;
}
```

Сконструируем второй объект **Student**, скопировав существующий:

```D
    // Конструируем первый объект:
    auto student1 = Student(1, [ 70, 90, 85 ]);

    // Конструируем второй объект, скопировав первый
    // и поменяем номер студента:
    auto student2 = student1;
    student2.number = 2;

    // ПРЕДУПРЕЖДЕНИЕ: Теперь оценки разделяются обеими объектами!

    // Изменение оценок первого студента ...
    student1.grades[0] += 5;

    // ... также затрагивает второго студента:
    writeln(student2.grades[0]);
```

После конструирования **student2** его члены получают значение членов
**student1**. **int** является объектом-значением, поэтому второй объект
получает собственное значение **number**.

Два объекта **Student** также имеют индивидуальные члены **grades**. Однако,
поскольку срезы являются ссылочными типами, фактически эти два среза разделяют
одинаковые элементы. Соответсвенно, изменение одного среза видимо в другом
срезе.

Вывод данного кода показывает, что у второго студента оценки также изменились:

    75

Поэтому лучшим подходом к конструированию второго объекта будет копирование
оценок первого:

```D
    // Второй Student конструируется с созданием копий оценок первого:
    auto student2 = Student(2, student1.grades.dup);

    // Изменение оценок первого студента ...
    student1.grades[0] += 5;

    // ... не влияет на оценки второго:
    writeln(student2.grades[0]);
```

Поскольку в этот раз **.dup** сделал копию оценок, у второго студента оценки 
не изменились:

    70

_Примечание: возможно осуществлять автоматическое копирование членов-ссылок.
Мы увидим, как это сделать, при рассмотрении функций-членов структуры._


## Структурные литералы





